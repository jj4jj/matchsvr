// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: matching.proto

#ifndef PROTOBUF_matching_2eproto__INCLUDED
#define PROTOBUF_matching_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "extensions.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_matching_2eproto();
void protobuf_AssignDesc_matching_2eproto();
void protobuf_ShutdownFile_matching_2eproto();

class MatchingPoint;
class MatchingObject;
class MatchingTeam;
class MatchedResult;
class MatchingQueueMatcher;
class MatchingWaitigTeam;
class MatchingBucket;
class MatchingQueue;
class Matching;

enum MatchingConstValues {
  MATCHING_TEAM_MAX_MEMBER_NUM = 3,
  MATCHING_TEAM_MAX_WAITING_MERGING_MEMBER_NUM = 2,
  MATCHING_TEAM_MAX_NUM_IN_LEVEL = 10000,
  MACTCHING_QUEUE_MAX_LEVEL_NUM = 26,
  MACTCHING_QUEUE_MAX_LEVEL = 25,
  MACTCHING_QUEUE_MAX_MACTCHED_RESULT_NUM = 10000,
  MATCHED_RESULT_TEAM_NUM = 2,
  MATCHED_RESULT_TEAM_L = 0,
  MATCHED_RESULT_TEAM_R = 1,
  MACTCHING_BUCKET_MAX_WAITING_TEAM_NUM = 1000,
  MATCHING_QUEUE_MAX_OBJECT_NUM = 500000
};
bool MatchingConstValues_IsValid(int value);
const MatchingConstValues MatchingConstValues_MIN = MATCHED_RESULT_TEAM_L;
const MatchingConstValues MatchingConstValues_MAX = MATCHING_QUEUE_MAX_OBJECT_NUM;
const int MatchingConstValues_ARRAYSIZE = MatchingConstValues_MAX + 1;

const ::google::protobuf::EnumDescriptor* MatchingConstValues_descriptor();
inline const ::std::string& MatchingConstValues_Name(MatchingConstValues value) {
  return ::google::protobuf::internal::NameOfEnum(
    MatchingConstValues_descriptor(), value);
}
inline bool MatchingConstValues_Parse(
    const ::std::string& name, MatchingConstValues* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MatchingConstValues>(
    MatchingConstValues_descriptor(), name, value);
}
// ===================================================================

class MatchingPoint : public ::google::protobuf::Message {
 public:
  MatchingPoint();
  virtual ~MatchingPoint();

  MatchingPoint(const MatchingPoint& from);

  inline MatchingPoint& operator=(const MatchingPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchingPoint& default_instance();

  void Swap(MatchingPoint* other);

  // implements Message ----------------------------------------------

  MatchingPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchingPoint& from);
  void MergeFrom(const MatchingPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 elo = 1;
  inline bool has_elo() const;
  inline void clear_elo();
  static const int kEloFieldNumber = 1;
  inline ::google::protobuf::uint32 elo() const;
  inline void set_elo(::google::protobuf::uint32 value);

  // optional uint32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MatchingPoint)
 private:
  inline void set_has_elo();
  inline void clear_has_elo();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 elo_;
  ::google::protobuf::uint32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_matching_2eproto();
  friend void protobuf_AssignDesc_matching_2eproto();
  friend void protobuf_ShutdownFile_matching_2eproto();

  void InitAsDefaultInstance();
  static MatchingPoint* default_instance_;
};
// -------------------------------------------------------------------

class MatchingObject : public ::google::protobuf::Message {
 public:
  MatchingObject();
  virtual ~MatchingObject();

  MatchingObject(const MatchingObject& from);

  inline MatchingObject& operator=(const MatchingObject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchingObject& default_instance();

  void Swap(MatchingObject* other);

  // implements Message ----------------------------------------------

  MatchingObject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchingObject& from);
  void MergeFrom(const MatchingObject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // required .MatchingPoint point = 2;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 2;
  inline const ::MatchingPoint& point() const;
  inline ::MatchingPoint* mutable_point();
  inline ::MatchingPoint* release_point();
  inline void set_allocated_point(::MatchingPoint* point);

  // @@protoc_insertion_point(class_scope:MatchingObject)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_point();
  inline void clear_has_point();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::MatchingPoint* point_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_matching_2eproto();
  friend void protobuf_AssignDesc_matching_2eproto();
  friend void protobuf_ShutdownFile_matching_2eproto();

  void InitAsDefaultInstance();
  static MatchingObject* default_instance_;
};
// -------------------------------------------------------------------

class MatchingTeam : public ::google::protobuf::Message {
 public:
  MatchingTeam();
  virtual ~MatchingTeam();

  MatchingTeam(const MatchingTeam& from);

  inline MatchingTeam& operator=(const MatchingTeam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchingTeam& default_instance();

  void Swap(MatchingTeam* other);

  // implements Message ----------------------------------------------

  MatchingTeam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchingTeam& from);
  void MergeFrom(const MatchingTeam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 members = 1;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 1;
  inline ::google::protobuf::uint64 members(int index) const;
  inline void set_members(int index, ::google::protobuf::uint64 value);
  inline void add_members(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      members() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_members();

  // required uint32 join_time = 2;
  inline bool has_join_time() const;
  inline void clear_join_time();
  static const int kJoinTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 join_time() const;
  inline void set_join_time(::google::protobuf::uint32 value);

  // required .MatchingPoint point = 3;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 3;
  inline const ::MatchingPoint& point() const;
  inline ::MatchingPoint* mutable_point();
  inline ::MatchingPoint* release_point();
  inline void set_allocated_point(::MatchingPoint* point);

  // @@protoc_insertion_point(class_scope:MatchingTeam)
 private:
  inline void set_has_join_time();
  inline void clear_has_join_time();
  inline void set_has_point();
  inline void clear_has_point();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > members_;
  ::MatchingPoint* point_;
  ::google::protobuf::uint32 join_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_matching_2eproto();
  friend void protobuf_AssignDesc_matching_2eproto();
  friend void protobuf_ShutdownFile_matching_2eproto();

  void InitAsDefaultInstance();
  static MatchingTeam* default_instance_;
};
// -------------------------------------------------------------------

class MatchedResult : public ::google::protobuf::Message {
 public:
  MatchedResult();
  virtual ~MatchedResult();

  MatchedResult(const MatchedResult& from);

  inline MatchedResult& operator=(const MatchedResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchedResult& default_instance();

  void Swap(MatchedResult* other);

  // implements Message ----------------------------------------------

  MatchedResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchedResult& from);
  void MergeFrom(const MatchedResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 teams = 1;
  inline int teams_size() const;
  inline void clear_teams();
  static const int kTeamsFieldNumber = 1;
  inline ::google::protobuf::uint64 teams(int index) const;
  inline void set_teams(int index, ::google::protobuf::uint64 value);
  inline void add_teams(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      teams() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_teams();

  // @@protoc_insertion_point(class_scope:MatchedResult)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > teams_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_matching_2eproto();
  friend void protobuf_AssignDesc_matching_2eproto();
  friend void protobuf_ShutdownFile_matching_2eproto();

  void InitAsDefaultInstance();
  static MatchedResult* default_instance_;
};
// -------------------------------------------------------------------

class MatchingQueueMatcher : public ::google::protobuf::Message {
 public:
  MatchingQueueMatcher();
  virtual ~MatchingQueueMatcher();

  MatchingQueueMatcher(const MatchingQueueMatcher& from);

  inline MatchingQueueMatcher& operator=(const MatchingQueueMatcher& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchingQueueMatcher& default_instance();

  void Swap(MatchingQueueMatcher* other);

  // implements Message ----------------------------------------------

  MatchingQueueMatcher* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchingQueueMatcher& from);
  void MergeFrom(const MatchingQueueMatcher& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 team_elo = 1;
  inline bool has_team_elo() const;
  inline void clear_team_elo();
  static const int kTeamEloFieldNumber = 1;
  inline ::google::protobuf::uint32 team_elo() const;
  inline void set_team_elo(::google::protobuf::uint32 value);

  // required uint32 team_id = 2;
  inline bool has_team_id() const;
  inline void clear_team_id();
  static const int kTeamIdFieldNumber = 2;
  inline ::google::protobuf::uint32 team_id() const;
  inline void set_team_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MatchingQueueMatcher)
 private:
  inline void set_has_team_elo();
  inline void clear_has_team_elo();
  inline void set_has_team_id();
  inline void clear_has_team_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 team_elo_;
  ::google::protobuf::uint32 team_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_matching_2eproto();
  friend void protobuf_AssignDesc_matching_2eproto();
  friend void protobuf_ShutdownFile_matching_2eproto();

  void InitAsDefaultInstance();
  static MatchingQueueMatcher* default_instance_;
};
// -------------------------------------------------------------------

class MatchingWaitigTeam : public ::google::protobuf::Message {
 public:
  MatchingWaitigTeam();
  virtual ~MatchingWaitigTeam();

  MatchingWaitigTeam(const MatchingWaitigTeam& from);

  inline MatchingWaitigTeam& operator=(const MatchingWaitigTeam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchingWaitigTeam& default_instance();

  void Swap(MatchingWaitigTeam* other);

  // implements Message ----------------------------------------------

  MatchingWaitigTeam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchingWaitigTeam& from);
  void MergeFrom(const MatchingWaitigTeam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MatchingQueueMatcher teams = 1;
  inline int teams_size() const;
  inline void clear_teams();
  static const int kTeamsFieldNumber = 1;
  inline const ::MatchingQueueMatcher& teams(int index) const;
  inline ::MatchingQueueMatcher* mutable_teams(int index);
  inline ::MatchingQueueMatcher* add_teams();
  inline const ::google::protobuf::RepeatedPtrField< ::MatchingQueueMatcher >&
      teams() const;
  inline ::google::protobuf::RepeatedPtrField< ::MatchingQueueMatcher >*
      mutable_teams();

  // @@protoc_insertion_point(class_scope:MatchingWaitigTeam)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::MatchingQueueMatcher > teams_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_matching_2eproto();
  friend void protobuf_AssignDesc_matching_2eproto();
  friend void protobuf_ShutdownFile_matching_2eproto();

  void InitAsDefaultInstance();
  static MatchingWaitigTeam* default_instance_;
};
// -------------------------------------------------------------------

class MatchingBucket : public ::google::protobuf::Message {
 public:
  MatchingBucket();
  virtual ~MatchingBucket();

  MatchingBucket(const MatchingBucket& from);

  inline MatchingBucket& operator=(const MatchingBucket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchingBucket& default_instance();

  void Swap(MatchingBucket* other);

  // implements Message ----------------------------------------------

  MatchingBucket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchingBucket& from);
  void MergeFrom(const MatchingBucket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MatchingWaitigTeam waitings = 1;
  inline int waitings_size() const;
  inline void clear_waitings();
  static const int kWaitingsFieldNumber = 1;
  inline const ::MatchingWaitigTeam& waitings(int index) const;
  inline ::MatchingWaitigTeam* mutable_waitings(int index);
  inline ::MatchingWaitigTeam* add_waitings();
  inline const ::google::protobuf::RepeatedPtrField< ::MatchingWaitigTeam >&
      waitings() const;
  inline ::google::protobuf::RepeatedPtrField< ::MatchingWaitigTeam >*
      mutable_waitings();

  // repeated .MatchingQueueMatcher matchers = 2;
  inline int matchers_size() const;
  inline void clear_matchers();
  static const int kMatchersFieldNumber = 2;
  inline const ::MatchingQueueMatcher& matchers(int index) const;
  inline ::MatchingQueueMatcher* mutable_matchers(int index);
  inline ::MatchingQueueMatcher* add_matchers();
  inline const ::google::protobuf::RepeatedPtrField< ::MatchingQueueMatcher >&
      matchers() const;
  inline ::google::protobuf::RepeatedPtrField< ::MatchingQueueMatcher >*
      mutable_matchers();

  // @@protoc_insertion_point(class_scope:MatchingBucket)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::MatchingWaitigTeam > waitings_;
  ::google::protobuf::RepeatedPtrField< ::MatchingQueueMatcher > matchers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_matching_2eproto();
  friend void protobuf_AssignDesc_matching_2eproto();
  friend void protobuf_ShutdownFile_matching_2eproto();

  void InitAsDefaultInstance();
  static MatchingBucket* default_instance_;
};
// -------------------------------------------------------------------

class MatchingQueue : public ::google::protobuf::Message {
 public:
  MatchingQueue();
  virtual ~MatchingQueue();

  MatchingQueue(const MatchingQueue& from);

  inline MatchingQueue& operator=(const MatchingQueue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchingQueue& default_instance();

  void Swap(MatchingQueue* other);

  // implements Message ----------------------------------------------

  MatchingQueue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchingQueue& from);
  void MergeFrom(const MatchingQueue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 team_member_num = 1;
  inline bool has_team_member_num() const;
  inline void clear_team_member_num();
  static const int kTeamMemberNumFieldNumber = 1;
  inline ::google::protobuf::uint32 team_member_num() const;
  inline void set_team_member_num(::google::protobuf::uint32 value);

  // repeated .MatchingBucket buckets = 2;
  inline int buckets_size() const;
  inline void clear_buckets();
  static const int kBucketsFieldNumber = 2;
  inline const ::MatchingBucket& buckets(int index) const;
  inline ::MatchingBucket* mutable_buckets(int index);
  inline ::MatchingBucket* add_buckets();
  inline const ::google::protobuf::RepeatedPtrField< ::MatchingBucket >&
      buckets() const;
  inline ::google::protobuf::RepeatedPtrField< ::MatchingBucket >*
      mutable_buckets();

  // required uint32 cur_time = 3;
  inline bool has_cur_time() const;
  inline void clear_cur_time();
  static const int kCurTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 cur_time() const;
  inline void set_cur_time(::google::protobuf::uint32 value);

  // required uint32 cur_ms_insec = 4;
  inline bool has_cur_ms_insec() const;
  inline void clear_cur_ms_insec();
  static const int kCurMsInsecFieldNumber = 4;
  inline ::google::protobuf::uint32 cur_ms_insec() const;
  inline void set_cur_ms_insec(::google::protobuf::uint32 value);

  // repeated .MatchedResult results = 5;
  inline int results_size() const;
  inline void clear_results();
  static const int kResultsFieldNumber = 5;
  inline const ::MatchedResult& results(int index) const;
  inline ::MatchedResult* mutable_results(int index);
  inline ::MatchedResult* add_results();
  inline const ::google::protobuf::RepeatedPtrField< ::MatchedResult >&
      results() const;
  inline ::google::protobuf::RepeatedPtrField< ::MatchedResult >*
      mutable_results();

  // optional uint32 fetched_results = 6;
  inline bool has_fetched_results() const;
  inline void clear_fetched_results();
  static const int kFetchedResultsFieldNumber = 6;
  inline ::google::protobuf::uint32 fetched_results() const;
  inline void set_fetched_results(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MatchingQueue)
 private:
  inline void set_has_team_member_num();
  inline void clear_has_team_member_num();
  inline void set_has_cur_time();
  inline void clear_has_cur_time();
  inline void set_has_cur_ms_insec();
  inline void clear_has_cur_ms_insec();
  inline void set_has_fetched_results();
  inline void clear_has_fetched_results();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::MatchingBucket > buckets_;
  ::google::protobuf::uint32 team_member_num_;
  ::google::protobuf::uint32 cur_time_;
  ::google::protobuf::RepeatedPtrField< ::MatchedResult > results_;
  ::google::protobuf::uint32 cur_ms_insec_;
  ::google::protobuf::uint32 fetched_results_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_matching_2eproto();
  friend void protobuf_AssignDesc_matching_2eproto();
  friend void protobuf_ShutdownFile_matching_2eproto();

  void InitAsDefaultInstance();
  static MatchingQueue* default_instance_;
};
// -------------------------------------------------------------------

class Matching : public ::google::protobuf::Message {
 public:
  Matching();
  virtual ~Matching();

  Matching(const Matching& from);

  inline Matching& operator=(const Matching& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Matching& default_instance();

  void Swap(Matching* other);

  // implements Message ----------------------------------------------

  Matching* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Matching& from);
  void MergeFrom(const Matching& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MatchingQueue q = 1;
  inline bool has_q() const;
  inline void clear_q();
  static const int kQFieldNumber = 1;
  inline const ::MatchingQueue& q() const;
  inline ::MatchingQueue* mutable_q();
  inline ::MatchingQueue* release_q();
  inline void set_allocated_q(::MatchingQueue* q);

  // optional .MatchingTeam mt = 2;
  inline bool has_mt() const;
  inline void clear_mt();
  static const int kMtFieldNumber = 2;
  inline const ::MatchingTeam& mt() const;
  inline ::MatchingTeam* mutable_mt();
  inline ::MatchingTeam* release_mt();
  inline void set_allocated_mt(::MatchingTeam* mt);

  // optional .MatchingObject mo = 3;
  inline bool has_mo() const;
  inline void clear_mo();
  static const int kMoFieldNumber = 3;
  inline const ::MatchingObject& mo() const;
  inline ::MatchingObject* mutable_mo();
  inline ::MatchingObject* release_mo();
  inline void set_allocated_mo(::MatchingObject* mo);

  // @@protoc_insertion_point(class_scope:Matching)
 private:
  inline void set_has_q();
  inline void clear_has_q();
  inline void set_has_mt();
  inline void clear_has_mt();
  inline void set_has_mo();
  inline void clear_has_mo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::MatchingQueue* q_;
  ::MatchingTeam* mt_;
  ::MatchingObject* mo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_matching_2eproto();
  friend void protobuf_AssignDesc_matching_2eproto();
  friend void protobuf_ShutdownFile_matching_2eproto();

  void InitAsDefaultInstance();
  static Matching* default_instance_;
};
// ===================================================================


// ===================================================================

// MatchingPoint

// required uint32 elo = 1;
inline bool MatchingPoint::has_elo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatchingPoint::set_has_elo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatchingPoint::clear_has_elo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatchingPoint::clear_elo() {
  elo_ = 0u;
  clear_has_elo();
}
inline ::google::protobuf::uint32 MatchingPoint::elo() const {
  return elo_;
}
inline void MatchingPoint::set_elo(::google::protobuf::uint32 value) {
  set_has_elo();
  elo_ = value;
}

// optional uint32 level = 2;
inline bool MatchingPoint::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MatchingPoint::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MatchingPoint::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MatchingPoint::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 MatchingPoint::level() const {
  return level_;
}
inline void MatchingPoint::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// MatchingObject

// required uint64 id = 1;
inline bool MatchingObject::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatchingObject::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatchingObject::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatchingObject::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 MatchingObject::id() const {
  return id_;
}
inline void MatchingObject::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// required .MatchingPoint point = 2;
inline bool MatchingObject::has_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MatchingObject::set_has_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MatchingObject::clear_has_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MatchingObject::clear_point() {
  if (point_ != NULL) point_->::MatchingPoint::Clear();
  clear_has_point();
}
inline const ::MatchingPoint& MatchingObject::point() const {
  return point_ != NULL ? *point_ : *default_instance_->point_;
}
inline ::MatchingPoint* MatchingObject::mutable_point() {
  set_has_point();
  if (point_ == NULL) point_ = new ::MatchingPoint;
  return point_;
}
inline ::MatchingPoint* MatchingObject::release_point() {
  clear_has_point();
  ::MatchingPoint* temp = point_;
  point_ = NULL;
  return temp;
}
inline void MatchingObject::set_allocated_point(::MatchingPoint* point) {
  delete point_;
  point_ = point;
  if (point) {
    set_has_point();
  } else {
    clear_has_point();
  }
}

// -------------------------------------------------------------------

// MatchingTeam

// repeated uint64 members = 1;
inline int MatchingTeam::members_size() const {
  return members_.size();
}
inline void MatchingTeam::clear_members() {
  members_.Clear();
}
inline ::google::protobuf::uint64 MatchingTeam::members(int index) const {
  return members_.Get(index);
}
inline void MatchingTeam::set_members(int index, ::google::protobuf::uint64 value) {
  members_.Set(index, value);
}
inline void MatchingTeam::add_members(::google::protobuf::uint64 value) {
  members_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
MatchingTeam::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
MatchingTeam::mutable_members() {
  return &members_;
}

// required uint32 join_time = 2;
inline bool MatchingTeam::has_join_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MatchingTeam::set_has_join_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MatchingTeam::clear_has_join_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MatchingTeam::clear_join_time() {
  join_time_ = 0u;
  clear_has_join_time();
}
inline ::google::protobuf::uint32 MatchingTeam::join_time() const {
  return join_time_;
}
inline void MatchingTeam::set_join_time(::google::protobuf::uint32 value) {
  set_has_join_time();
  join_time_ = value;
}

// required .MatchingPoint point = 3;
inline bool MatchingTeam::has_point() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MatchingTeam::set_has_point() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MatchingTeam::clear_has_point() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MatchingTeam::clear_point() {
  if (point_ != NULL) point_->::MatchingPoint::Clear();
  clear_has_point();
}
inline const ::MatchingPoint& MatchingTeam::point() const {
  return point_ != NULL ? *point_ : *default_instance_->point_;
}
inline ::MatchingPoint* MatchingTeam::mutable_point() {
  set_has_point();
  if (point_ == NULL) point_ = new ::MatchingPoint;
  return point_;
}
inline ::MatchingPoint* MatchingTeam::release_point() {
  clear_has_point();
  ::MatchingPoint* temp = point_;
  point_ = NULL;
  return temp;
}
inline void MatchingTeam::set_allocated_point(::MatchingPoint* point) {
  delete point_;
  point_ = point;
  if (point) {
    set_has_point();
  } else {
    clear_has_point();
  }
}

// -------------------------------------------------------------------

// MatchedResult

// repeated uint64 teams = 1;
inline int MatchedResult::teams_size() const {
  return teams_.size();
}
inline void MatchedResult::clear_teams() {
  teams_.Clear();
}
inline ::google::protobuf::uint64 MatchedResult::teams(int index) const {
  return teams_.Get(index);
}
inline void MatchedResult::set_teams(int index, ::google::protobuf::uint64 value) {
  teams_.Set(index, value);
}
inline void MatchedResult::add_teams(::google::protobuf::uint64 value) {
  teams_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
MatchedResult::teams() const {
  return teams_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
MatchedResult::mutable_teams() {
  return &teams_;
}

// -------------------------------------------------------------------

// MatchingQueueMatcher

// required uint32 team_elo = 1;
inline bool MatchingQueueMatcher::has_team_elo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatchingQueueMatcher::set_has_team_elo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatchingQueueMatcher::clear_has_team_elo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatchingQueueMatcher::clear_team_elo() {
  team_elo_ = 0u;
  clear_has_team_elo();
}
inline ::google::protobuf::uint32 MatchingQueueMatcher::team_elo() const {
  return team_elo_;
}
inline void MatchingQueueMatcher::set_team_elo(::google::protobuf::uint32 value) {
  set_has_team_elo();
  team_elo_ = value;
}

// required uint32 team_id = 2;
inline bool MatchingQueueMatcher::has_team_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MatchingQueueMatcher::set_has_team_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MatchingQueueMatcher::clear_has_team_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MatchingQueueMatcher::clear_team_id() {
  team_id_ = 0u;
  clear_has_team_id();
}
inline ::google::protobuf::uint32 MatchingQueueMatcher::team_id() const {
  return team_id_;
}
inline void MatchingQueueMatcher::set_team_id(::google::protobuf::uint32 value) {
  set_has_team_id();
  team_id_ = value;
}

// -------------------------------------------------------------------

// MatchingWaitigTeam

// repeated .MatchingQueueMatcher teams = 1;
inline int MatchingWaitigTeam::teams_size() const {
  return teams_.size();
}
inline void MatchingWaitigTeam::clear_teams() {
  teams_.Clear();
}
inline const ::MatchingQueueMatcher& MatchingWaitigTeam::teams(int index) const {
  return teams_.Get(index);
}
inline ::MatchingQueueMatcher* MatchingWaitigTeam::mutable_teams(int index) {
  return teams_.Mutable(index);
}
inline ::MatchingQueueMatcher* MatchingWaitigTeam::add_teams() {
  return teams_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MatchingQueueMatcher >&
MatchingWaitigTeam::teams() const {
  return teams_;
}
inline ::google::protobuf::RepeatedPtrField< ::MatchingQueueMatcher >*
MatchingWaitigTeam::mutable_teams() {
  return &teams_;
}

// -------------------------------------------------------------------

// MatchingBucket

// repeated .MatchingWaitigTeam waitings = 1;
inline int MatchingBucket::waitings_size() const {
  return waitings_.size();
}
inline void MatchingBucket::clear_waitings() {
  waitings_.Clear();
}
inline const ::MatchingWaitigTeam& MatchingBucket::waitings(int index) const {
  return waitings_.Get(index);
}
inline ::MatchingWaitigTeam* MatchingBucket::mutable_waitings(int index) {
  return waitings_.Mutable(index);
}
inline ::MatchingWaitigTeam* MatchingBucket::add_waitings() {
  return waitings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MatchingWaitigTeam >&
MatchingBucket::waitings() const {
  return waitings_;
}
inline ::google::protobuf::RepeatedPtrField< ::MatchingWaitigTeam >*
MatchingBucket::mutable_waitings() {
  return &waitings_;
}

// repeated .MatchingQueueMatcher matchers = 2;
inline int MatchingBucket::matchers_size() const {
  return matchers_.size();
}
inline void MatchingBucket::clear_matchers() {
  matchers_.Clear();
}
inline const ::MatchingQueueMatcher& MatchingBucket::matchers(int index) const {
  return matchers_.Get(index);
}
inline ::MatchingQueueMatcher* MatchingBucket::mutable_matchers(int index) {
  return matchers_.Mutable(index);
}
inline ::MatchingQueueMatcher* MatchingBucket::add_matchers() {
  return matchers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MatchingQueueMatcher >&
MatchingBucket::matchers() const {
  return matchers_;
}
inline ::google::protobuf::RepeatedPtrField< ::MatchingQueueMatcher >*
MatchingBucket::mutable_matchers() {
  return &matchers_;
}

// -------------------------------------------------------------------

// MatchingQueue

// required uint32 team_member_num = 1;
inline bool MatchingQueue::has_team_member_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatchingQueue::set_has_team_member_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatchingQueue::clear_has_team_member_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatchingQueue::clear_team_member_num() {
  team_member_num_ = 0u;
  clear_has_team_member_num();
}
inline ::google::protobuf::uint32 MatchingQueue::team_member_num() const {
  return team_member_num_;
}
inline void MatchingQueue::set_team_member_num(::google::protobuf::uint32 value) {
  set_has_team_member_num();
  team_member_num_ = value;
}

// repeated .MatchingBucket buckets = 2;
inline int MatchingQueue::buckets_size() const {
  return buckets_.size();
}
inline void MatchingQueue::clear_buckets() {
  buckets_.Clear();
}
inline const ::MatchingBucket& MatchingQueue::buckets(int index) const {
  return buckets_.Get(index);
}
inline ::MatchingBucket* MatchingQueue::mutable_buckets(int index) {
  return buckets_.Mutable(index);
}
inline ::MatchingBucket* MatchingQueue::add_buckets() {
  return buckets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MatchingBucket >&
MatchingQueue::buckets() const {
  return buckets_;
}
inline ::google::protobuf::RepeatedPtrField< ::MatchingBucket >*
MatchingQueue::mutable_buckets() {
  return &buckets_;
}

// required uint32 cur_time = 3;
inline bool MatchingQueue::has_cur_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MatchingQueue::set_has_cur_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MatchingQueue::clear_has_cur_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MatchingQueue::clear_cur_time() {
  cur_time_ = 0u;
  clear_has_cur_time();
}
inline ::google::protobuf::uint32 MatchingQueue::cur_time() const {
  return cur_time_;
}
inline void MatchingQueue::set_cur_time(::google::protobuf::uint32 value) {
  set_has_cur_time();
  cur_time_ = value;
}

// required uint32 cur_ms_insec = 4;
inline bool MatchingQueue::has_cur_ms_insec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MatchingQueue::set_has_cur_ms_insec() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MatchingQueue::clear_has_cur_ms_insec() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MatchingQueue::clear_cur_ms_insec() {
  cur_ms_insec_ = 0u;
  clear_has_cur_ms_insec();
}
inline ::google::protobuf::uint32 MatchingQueue::cur_ms_insec() const {
  return cur_ms_insec_;
}
inline void MatchingQueue::set_cur_ms_insec(::google::protobuf::uint32 value) {
  set_has_cur_ms_insec();
  cur_ms_insec_ = value;
}

// repeated .MatchedResult results = 5;
inline int MatchingQueue::results_size() const {
  return results_.size();
}
inline void MatchingQueue::clear_results() {
  results_.Clear();
}
inline const ::MatchedResult& MatchingQueue::results(int index) const {
  return results_.Get(index);
}
inline ::MatchedResult* MatchingQueue::mutable_results(int index) {
  return results_.Mutable(index);
}
inline ::MatchedResult* MatchingQueue::add_results() {
  return results_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MatchedResult >&
MatchingQueue::results() const {
  return results_;
}
inline ::google::protobuf::RepeatedPtrField< ::MatchedResult >*
MatchingQueue::mutable_results() {
  return &results_;
}

// optional uint32 fetched_results = 6;
inline bool MatchingQueue::has_fetched_results() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MatchingQueue::set_has_fetched_results() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MatchingQueue::clear_has_fetched_results() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MatchingQueue::clear_fetched_results() {
  fetched_results_ = 0u;
  clear_has_fetched_results();
}
inline ::google::protobuf::uint32 MatchingQueue::fetched_results() const {
  return fetched_results_;
}
inline void MatchingQueue::set_fetched_results(::google::protobuf::uint32 value) {
  set_has_fetched_results();
  fetched_results_ = value;
}

// -------------------------------------------------------------------

// Matching

// optional .MatchingQueue q = 1;
inline bool Matching::has_q() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Matching::set_has_q() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Matching::clear_has_q() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Matching::clear_q() {
  if (q_ != NULL) q_->::MatchingQueue::Clear();
  clear_has_q();
}
inline const ::MatchingQueue& Matching::q() const {
  return q_ != NULL ? *q_ : *default_instance_->q_;
}
inline ::MatchingQueue* Matching::mutable_q() {
  set_has_q();
  if (q_ == NULL) q_ = new ::MatchingQueue;
  return q_;
}
inline ::MatchingQueue* Matching::release_q() {
  clear_has_q();
  ::MatchingQueue* temp = q_;
  q_ = NULL;
  return temp;
}
inline void Matching::set_allocated_q(::MatchingQueue* q) {
  delete q_;
  q_ = q;
  if (q) {
    set_has_q();
  } else {
    clear_has_q();
  }
}

// optional .MatchingTeam mt = 2;
inline bool Matching::has_mt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Matching::set_has_mt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Matching::clear_has_mt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Matching::clear_mt() {
  if (mt_ != NULL) mt_->::MatchingTeam::Clear();
  clear_has_mt();
}
inline const ::MatchingTeam& Matching::mt() const {
  return mt_ != NULL ? *mt_ : *default_instance_->mt_;
}
inline ::MatchingTeam* Matching::mutable_mt() {
  set_has_mt();
  if (mt_ == NULL) mt_ = new ::MatchingTeam;
  return mt_;
}
inline ::MatchingTeam* Matching::release_mt() {
  clear_has_mt();
  ::MatchingTeam* temp = mt_;
  mt_ = NULL;
  return temp;
}
inline void Matching::set_allocated_mt(::MatchingTeam* mt) {
  delete mt_;
  mt_ = mt;
  if (mt) {
    set_has_mt();
  } else {
    clear_has_mt();
  }
}

// optional .MatchingObject mo = 3;
inline bool Matching::has_mo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Matching::set_has_mo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Matching::clear_has_mo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Matching::clear_mo() {
  if (mo_ != NULL) mo_->::MatchingObject::Clear();
  clear_has_mo();
}
inline const ::MatchingObject& Matching::mo() const {
  return mo_ != NULL ? *mo_ : *default_instance_->mo_;
}
inline ::MatchingObject* Matching::mutable_mo() {
  set_has_mo();
  if (mo_ == NULL) mo_ = new ::MatchingObject;
  return mo_;
}
inline ::MatchingObject* Matching::release_mo() {
  clear_has_mo();
  ::MatchingObject* temp = mo_;
  mo_ = NULL;
  return temp;
}
inline void Matching::set_allocated_mo(::MatchingObject* mo) {
  delete mo_;
  mo_ = mo;
  if (mo) {
    set_has_mo();
  } else {
    clear_has_mo();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MatchingConstValues>() {
  return ::MatchingConstValues_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_matching_2eproto__INCLUDED
