#ifndef __PBDCEX_H_DEF_MATCHING_CEX_HPP__
#define __PBDCEX_H_DEF_MATCHING_CEX_HPP__
//#pragma once
//This file is auto generated by pbdcex [http://github.com/jj4jj/pbdcex.git],
//Please do NOT edit it ! Any bug please let jj4jj known .
//File generated time: Sun Jun 12 14:55:03 2016
#include "matching.pb.h"
#include "pbdcex.core.hpp"
using pbdcex::string_t;
using pbdcex::bytes_t;
using pbdcex::array_t;
using pbdcex::serializable_t;
struct MatchingQueueMatcher_ST : public serializable_t<MatchingQueueMatcher_ST, MatchingQueueMatcher> {
    uint32_t                               team_elo;
    uint32_t                               team_id;
    ////////////////////////////////////////////////////////////////////////
    void    construct(){
        if(sizeof(*this) < 1024){
            memset(this, 0, sizeof(*this));
        }
        else {
            team_elo=static_cast<uint32_t>(0);
            team_id=static_cast<uint32_t>(0);
        }
    }
    int     convto(MatchingQueueMatcher & tomsg_) const {
        int ret = 0;
        tomsg_.Clear();
        tomsg_.set_team_elo(this->team_elo);
        tomsg_.set_team_id(this->team_id);
        return ret;
    }
    int     convfrom(const MatchingQueueMatcher & frommsg_) {
		int ret = 0;
        this->team_elo = frommsg_.team_elo();
        this->team_id = frommsg_.team_id();
        return ret;
    }
    int     compare(const MatchingQueueMatcher_ST & rhs_) const {
        int cmp = 0;
        if (this->team_elo < rhs_.team_elo){
            return -1;
        }
        else if(this->team_elo > rhs_.team_elo){
            return 1;
        }
        return 0;
    }
    bool    operator == (const MatchingQueueMatcher_ST & rhs_) const {
        return this->compare(rhs_) == 0;
    }
    bool    operator < (const MatchingQueueMatcher_ST & rhs_) const {
        return this->compare(rhs_) < 0;
    }
};
struct MatchingWaitigTeam_ST : public serializable_t<MatchingWaitigTeam_ST, MatchingWaitigTeam> {
    array_t<MatchingQueueMatcher_ST, MACTCHING_BUCKET_MAX_WAITING_TEAM_NUM>       teams;
    ////////////////////////////////////////////////////////////////////////
    void    construct(){
        if(sizeof(*this) < 1024){
            memset(this, 0, sizeof(*this));
        }
        else {
            teams.construct();
        }
    }
    int     convto(MatchingWaitigTeam & tomsg_) const {
        int ret = 0;
        tomsg_.Clear();
        for (int i = 0;i < teams.count; ++i){
            ret = this->teams.list[i].convto(*tomsg_.add_teams());
            if (ret){return __LINE__+ret;}
            }
        return ret;
    }
    int     convfrom(const MatchingWaitigTeam & frommsg_) {
		int ret = 0;
        this->teams.count=0;
        for (int i = 0;i < frommsg_.teams_size() && i < MACTCHING_BUCKET_MAX_WAITING_TEAM_NUM; ++i,++(this->teams.count)){
            ret = this->teams.list[i].convfrom(frommsg_.teams(i));
            if (ret) {return __LINE__+ret;}
        }
        return ret;
    }
    int     compare(const MatchingWaitigTeam_ST & rhs_) const {
        int cmp = 0;
        cmp = this->teams.compare(rhs_.teams);
        if(cmp){return cmp;}
        return 0;
    }
    bool    operator == (const MatchingWaitigTeam_ST & rhs_) const {
        return this->compare(rhs_) == 0;
    }
    bool    operator < (const MatchingWaitigTeam_ST & rhs_) const {
        return this->compare(rhs_) < 0;
    }
};
struct MatchingPoint_ST : public serializable_t<MatchingPoint_ST, MatchingPoint> {
    uint32_t                               elo;
    uint32_t                               level;
    ////////////////////////////////////////////////////////////////////////
    void    construct(){
        if(sizeof(*this) < 1024){
            memset(this, 0, sizeof(*this));
        }
        else {
            elo=static_cast<uint32_t>(0);
            level=static_cast<uint32_t>(0);
        }
    }
    int     convto(MatchingPoint & tomsg_) const {
        int ret = 0;
        tomsg_.Clear();
        tomsg_.set_elo(this->elo);
        tomsg_.set_level(this->level);
        return ret;
    }
    int     convfrom(const MatchingPoint & frommsg_) {
		int ret = 0;
        this->elo = frommsg_.elo();
        this->level = frommsg_.level();
        return ret;
    }
    int     compare(const MatchingPoint_ST & rhs_) const {
        int cmp = 0;
        if (this->elo < rhs_.elo){
            return -1;
        }
        else if(this->elo > rhs_.elo){
            return 1;
        }
        if (this->level < rhs_.level){
            return -1;
        }
        else if(this->level > rhs_.level){
            return 1;
        }
        return 0;
    }
    bool    operator == (const MatchingPoint_ST & rhs_) const {
        return this->compare(rhs_) == 0;
    }
    bool    operator < (const MatchingPoint_ST & rhs_) const {
        return this->compare(rhs_) < 0;
    }
};
struct MatchedResult_ST : public serializable_t<MatchedResult_ST, MatchedResult> {
    array_t<uint64_t, MATCHING_TEAM_MAX_MEMBER_NUM>       teams;
    ////////////////////////////////////////////////////////////////////////
    void    construct(){
        if(sizeof(*this) < 1024){
            memset(this, 0, sizeof(*this));
        }
        else {
            teams.construct();
        }
    }
    int     convto(MatchedResult & tomsg_) const {
        int ret = 0;
        tomsg_.Clear();
        for (int i = 0;i < teams.count; ++i){
            tomsg_.add_teams(this->teams.list[i]);
            }
        return ret;
    }
    int     convfrom(const MatchedResult & frommsg_) {
		int ret = 0;
        this->teams.count=0;
        for (int i = 0;i < frommsg_.teams_size() && i < MATCHING_TEAM_MAX_MEMBER_NUM; ++i,++(this->teams.count)){
            this->teams.list[i] = frommsg_.teams(i);
        }
        return ret;
    }
    int     compare(const MatchedResult_ST & rhs_) const {
        int cmp = 0;
        cmp = this->teams.compare(rhs_.teams);
        if(cmp){return cmp;}
        return 0;
    }
    bool    operator == (const MatchedResult_ST & rhs_) const {
        return this->compare(rhs_) == 0;
    }
    bool    operator < (const MatchedResult_ST & rhs_) const {
        return this->compare(rhs_) < 0;
    }
};
struct MatchingBucket_ST : public serializable_t<MatchingBucket_ST, MatchingBucket> {
    array_t<MatchingWaitigTeam_ST, MATCHING_TEAM_MAX_WAITING_MERGING_MEMBER_NUM>       waitings;
    array_t<MatchingQueueMatcher_ST, MATCHING_TEAM_MAX_NUM_IN_LEVEL>       matchers;
    ////////////////////////////////////////////////////////////////////////
    void    construct(){
        if(sizeof(*this) < 1024){
            memset(this, 0, sizeof(*this));
        }
        else {
            waitings.construct();
            matchers.construct();
        }
    }
    int     convto(MatchingBucket & tomsg_) const {
        int ret = 0;
        tomsg_.Clear();
        for (int i = 0;i < waitings.count; ++i){
            ret = this->waitings.list[i].convto(*tomsg_.add_waitings());
            if (ret){return __LINE__+ret;}
            }
        for (int i = 0;i < matchers.count; ++i){
            ret = this->matchers.list[i].convto(*tomsg_.add_matchers());
            if (ret){return __LINE__+ret;}
            }
        return ret;
    }
    int     convfrom(const MatchingBucket & frommsg_) {
		int ret = 0;
        this->waitings.count=0;
        for (int i = 0;i < frommsg_.waitings_size() && i < MATCHING_TEAM_MAX_WAITING_MERGING_MEMBER_NUM; ++i,++(this->waitings.count)){
            ret = this->waitings.list[i].convfrom(frommsg_.waitings(i));
            if (ret) {return __LINE__+ret;}
        }
        this->matchers.count=0;
        for (int i = 0;i < frommsg_.matchers_size() && i < MATCHING_TEAM_MAX_NUM_IN_LEVEL; ++i,++(this->matchers.count)){
            ret = this->matchers.list[i].convfrom(frommsg_.matchers(i));
            if (ret) {return __LINE__+ret;}
        }
        return ret;
    }
    int     compare(const MatchingBucket_ST & rhs_) const {
        int cmp = 0;
        cmp = this->waitings.compare(rhs_.waitings);
        if(cmp){return cmp;}
        cmp = this->matchers.compare(rhs_.matchers);
        if(cmp){return cmp;}
        return 0;
    }
    bool    operator == (const MatchingBucket_ST & rhs_) const {
        return this->compare(rhs_) == 0;
    }
    bool    operator < (const MatchingBucket_ST & rhs_) const {
        return this->compare(rhs_) < 0;
    }
};
struct MatchingObject_ST : public serializable_t<MatchingObject_ST, MatchingObject> {
    uint64_t                               id;
    MatchingPoint_ST                       point;
    ////////////////////////////////////////////////////////////////////////
    void    construct(){
        if(sizeof(*this) < 1024){
            memset(this, 0, sizeof(*this));
        }
        else {
            id=static_cast<uint64_t>(0);
            point.construct();
        }
    }
    int     convto(MatchingObject & tomsg_) const {
        int ret = 0;
        tomsg_.Clear();
        tomsg_.set_id(this->id);
        ret = this->point.convto(*tomsg_.mutable_point());
        if (ret) {return __LINE__+ret;}
        return ret;
    }
    int     convfrom(const MatchingObject & frommsg_) {
		int ret = 0;
        this->id = frommsg_.id();
        ret = this->point.convfrom(frommsg_.point());
        if (ret) {return __LINE__+ret;}
        return ret;
    }
    int     compare(const MatchingObject_ST & rhs_) const {
        int cmp = 0;
        if (this->id < rhs_.id){
            return -1;
        }
        else if(this->id > rhs_.id){
            return 1;
        }
        return 0;
    }
    bool    operator == (const MatchingObject_ST & rhs_) const {
        return this->compare(rhs_) == 0;
    }
    bool    operator < (const MatchingObject_ST & rhs_) const {
        return this->compare(rhs_) < 0;
    }
};
struct MatchingTeam_ST : public serializable_t<MatchingTeam_ST, MatchingTeam> {
    array_t<uint64_t, MATCHING_TEAM_MAX_MEMBER_NUM>       members;
    uint32_t                               join_time;
    MatchingPoint_ST                       point;
    ////////////////////////////////////////////////////////////////////////
    void    construct(){
        if(sizeof(*this) < 1024){
            memset(this, 0, sizeof(*this));
        }
        else {
            members.construct();
            join_time=static_cast<uint32_t>(0);
            point.construct();
        }
    }
    int     convto(MatchingTeam & tomsg_) const {
        int ret = 0;
        tomsg_.Clear();
        for (int i = 0;i < members.count; ++i){
            tomsg_.add_members(this->members.list[i]);
            }
        tomsg_.set_join_time(this->join_time);
        ret = this->point.convto(*tomsg_.mutable_point());
        if (ret) {return __LINE__+ret;}
        return ret;
    }
    int     convfrom(const MatchingTeam & frommsg_) {
		int ret = 0;
        this->members.count=0;
        for (int i = 0;i < frommsg_.members_size() && i < MATCHING_TEAM_MAX_MEMBER_NUM; ++i,++(this->members.count)){
            this->members.list[i] = frommsg_.members(i);
        }
        this->join_time = frommsg_.join_time();
        ret = this->point.convfrom(frommsg_.point());
        if (ret) {return __LINE__+ret;}
        return ret;
    }
    int     compare(const MatchingTeam_ST & rhs_) const {
        int cmp = 0;
        cmp = this->members.compare(rhs_.members);
        if(cmp){return cmp;}
        if (this->join_time < rhs_.join_time){
            return -1;
        }
        else if(this->join_time > rhs_.join_time){
            return 1;
        }
        cmp = this->point.compare(rhs_.point);
        if(cmp){return cmp;}
        return 0;
    }
    bool    operator == (const MatchingTeam_ST & rhs_) const {
        return this->compare(rhs_) == 0;
    }
    bool    operator < (const MatchingTeam_ST & rhs_) const {
        return this->compare(rhs_) < 0;
    }
};
struct MatchingQueue_ST : public serializable_t<MatchingQueue_ST, MatchingQueue> {
    uint32_t                               team_member_num;
    array_t<MatchingBucket_ST, MACTCHING_QUEUE_MAX_LEVEL_NUM>       buckets;
    uint32_t                               cur_time;
    uint32_t                               cur_ms_insec;
    array_t<MatchedResult_ST, MACTCHING_QUEUE_MAX_MACTCHED_RESULT_NUM>       results;
    uint32_t                               fetched_results;
    ////////////////////////////////////////////////////////////////////////
    void    construct(){
        if(sizeof(*this) < 1024){
            memset(this, 0, sizeof(*this));
        }
        else {
            team_member_num=static_cast<uint32_t>(0);
            buckets.construct();
            cur_time=static_cast<uint32_t>(0);
            cur_ms_insec=static_cast<uint32_t>(0);
            results.construct();
            fetched_results=static_cast<uint32_t>(0);
        }
    }
    int     convto(MatchingQueue & tomsg_) const {
        int ret = 0;
        tomsg_.Clear();
        tomsg_.set_team_member_num(this->team_member_num);
        for (int i = 0;i < buckets.count; ++i){
            ret = this->buckets.list[i].convto(*tomsg_.add_buckets());
            if (ret){return __LINE__+ret;}
            }
        tomsg_.set_cur_time(this->cur_time);
        tomsg_.set_cur_ms_insec(this->cur_ms_insec);
        for (int i = 0;i < results.count; ++i){
            ret = this->results.list[i].convto(*tomsg_.add_results());
            if (ret){return __LINE__+ret;}
            }
        tomsg_.set_fetched_results(this->fetched_results);
        return ret;
    }
    int     convfrom(const MatchingQueue & frommsg_) {
		int ret = 0;
        this->team_member_num = frommsg_.team_member_num();
        this->buckets.count=0;
        for (int i = 0;i < frommsg_.buckets_size() && i < MACTCHING_QUEUE_MAX_LEVEL_NUM; ++i,++(this->buckets.count)){
            ret = this->buckets.list[i].convfrom(frommsg_.buckets(i));
            if (ret) {return __LINE__+ret;}
        }
        this->cur_time = frommsg_.cur_time();
        this->cur_ms_insec = frommsg_.cur_ms_insec();
        this->results.count=0;
        for (int i = 0;i < frommsg_.results_size() && i < MACTCHING_QUEUE_MAX_MACTCHED_RESULT_NUM; ++i,++(this->results.count)){
            ret = this->results.list[i].convfrom(frommsg_.results(i));
            if (ret) {return __LINE__+ret;}
        }
        this->fetched_results = frommsg_.fetched_results();
        return ret;
    }
    int     compare(const MatchingQueue_ST & rhs_) const {
        int cmp = 0;
        if (this->team_member_num < rhs_.team_member_num){
            return -1;
        }
        else if(this->team_member_num > rhs_.team_member_num){
            return 1;
        }
        cmp = this->buckets.compare(rhs_.buckets);
        if(cmp){return cmp;}
        if (this->cur_time < rhs_.cur_time){
            return -1;
        }
        else if(this->cur_time > rhs_.cur_time){
            return 1;
        }
        if (this->cur_ms_insec < rhs_.cur_ms_insec){
            return -1;
        }
        else if(this->cur_ms_insec > rhs_.cur_ms_insec){
            return 1;
        }
        cmp = this->results.compare(rhs_.results);
        if(cmp){return cmp;}
        if (this->fetched_results < rhs_.fetched_results){
            return -1;
        }
        else if(this->fetched_results > rhs_.fetched_results){
            return 1;
        }
        return 0;
    }
    bool    operator == (const MatchingQueue_ST & rhs_) const {
        return this->compare(rhs_) == 0;
    }
    bool    operator < (const MatchingQueue_ST & rhs_) const {
        return this->compare(rhs_) < 0;
    }
};
struct Matching_ST : public serializable_t<Matching_ST, Matching> {
    MatchingQueue_ST                       q;
    MatchingTeam_ST                        mt;
    MatchingObject_ST                      mo;
    ////////////////////////////////////////////////////////////////////////
    void    construct(){
        if(sizeof(*this) < 1024){
            memset(this, 0, sizeof(*this));
        }
        else {
            q.construct();
            mt.construct();
            mo.construct();
        }
    }
    int     convto(Matching & tomsg_) const {
        int ret = 0;
        tomsg_.Clear();
        ret = this->q.convto(*tomsg_.mutable_q());
        if (ret) {return __LINE__+ret;}
        ret = this->mt.convto(*tomsg_.mutable_mt());
        if (ret) {return __LINE__+ret;}
        ret = this->mo.convto(*tomsg_.mutable_mo());
        if (ret) {return __LINE__+ret;}
        return ret;
    }
    int     convfrom(const Matching & frommsg_) {
		int ret = 0;
        ret = this->q.convfrom(frommsg_.q());
        if (ret) {return __LINE__+ret;}
        ret = this->mt.convfrom(frommsg_.mt());
        if (ret) {return __LINE__+ret;}
        ret = this->mo.convfrom(frommsg_.mo());
        if (ret) {return __LINE__+ret;}
        return ret;
    }
    int     compare(const Matching_ST & rhs_) const {
        int cmp = 0;
        cmp = this->q.compare(rhs_.q);
        if(cmp){return cmp;}
        cmp = this->mt.compare(rhs_.mt);
        if(cmp){return cmp;}
        cmp = this->mo.compare(rhs_.mo);
        if(cmp){return cmp;}
        return 0;
    }
    bool    operator == (const Matching_ST & rhs_) const {
        return this->compare(rhs_) == 0;
    }
    bool    operator < (const Matching_ST & rhs_) const {
        return this->compare(rhs_) < 0;
    }
};
#endif
